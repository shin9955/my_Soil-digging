<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>土ひろい10秒ゲーム</title>
    <style>
      :root {
        --ink: #2b1f17;
        --ink-soft: #5a4333;
        --paper: #fff7ea;
        --paper-strong: #f3d9be;
        --accent: #f4a259;
        --accent-strong: #e07a3f;
        --grass: #8cc07b;
        --soil-dark: #6b3e22;
        --soil-mid: #8a5631;
        --soil-light: #b57a49;
        --shadow: rgba(43, 31, 23, 0.2);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Trebuchet MS", "Gill Sans", "Optima", "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(1200px 700px at 10% -10%, #fff6e9 0%, #f3d9be 50%, #ddb089 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: stretch;
        padding: 24px;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image: radial-gradient(circle at 1px 1px, rgba(0, 0, 0, 0.05) 1px, transparent 0);
        background-size: 18px 18px;
        opacity: 0.4;
        pointer-events: none;
      }

      .app {
        width: min(1100px, 100%);
        display: grid;
        gap: 20px;
      }

      .hero {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        justify-content: space-between;
        align-items: center;
      }

      .hero h1 {
        margin: 0;
        font-size: clamp(28px, 4vw, 40px);
        letter-spacing: 0.04em;
      }

      .hero p {
        margin: 6px 0 0;
        color: var(--ink-soft);
        max-width: 560px;
      }

      .badge {
        background: linear-gradient(140deg, var(--accent), var(--accent-strong));
        color: #fff;
        padding: 10px 18px;
        border-radius: 999px;
        font-weight: 700;
        box-shadow: 0 10px 20px rgba(224, 122, 63, 0.3);
      }

      .panel {
        background: rgba(255, 255, 255, 0.8);
        border-radius: 20px;
        padding: 18px;
        box-shadow: 0 12px 30px var(--shadow);
        display: grid;
        gap: 18px;
        backdrop-filter: blur(6px);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 12px;
      }

      .stat {
        background: var(--paper);
        border-radius: 14px;
        padding: 12px 14px;
        display: grid;
        gap: 6px;
        box-shadow: inset 0 0 0 1px rgba(90, 67, 51, 0.1);
      }

      .stat span {
        font-size: 22px;
        font-weight: 800;
      }

      .controls {
        display: grid;
        gap: 12px;
      }

      .control-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
      }

      label {
        display: grid;
        gap: 6px;
        font-weight: 600;
        color: var(--ink-soft);
      }

      input[type="number"] {
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(90, 67, 51, 0.2);
        font-size: 16px;
        background: #fff;
      }

      fieldset {
        border: 1px solid rgba(90, 67, 51, 0.2);
        border-radius: 12px;
        padding: 10px 12px 12px;
      }

      legend {
        padding: 0 6px;
        font-weight: 700;
        color: var(--ink-soft);
      }

      .difficulty {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .difficulty label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-weight: 700;
        color: var(--ink);
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 13px;
        color: var(--ink-soft);
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #fff;
        border-radius: 999px;
        padding: 6px 10px;
        box-shadow: inset 0 0 0 1px rgba(90, 67, 51, 0.15);
      }

      .legend-dot {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--legend-color, var(--soil-light));
        box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.15);
      }

      .buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      button {
        border: none;
        border-radius: 12px;
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
      }

      .btn-start {
        background: linear-gradient(130deg, #f4a259, #f26c4f);
        color: #fff;
        box-shadow: 0 12px 20px rgba(242, 108, 79, 0.25);
      }

      .btn-reset {
        background: #fff;
        color: var(--ink);
        box-shadow: inset 0 0 0 2px rgba(90, 67, 51, 0.15);
      }

      .btn-start:active,
      .btn-reset:active {
        transform: translateY(2px);
      }

      .tuning {
        font-size: 13px;
        color: var(--ink-soft);
        margin: 0;
      }

      .field-wrap {
        position: relative;
        border-radius: 26px;
        overflow: hidden;
        background: linear-gradient(180deg, #caa27e 0%, #b3825f 60%, #8a6043 100%);
        box-shadow: 0 20px 40px rgba(43, 31, 23, 0.3);
        height: 60vh;
        min-height: 320px;
        max-height: 520px;
      }

      #field {
        position: relative;
        width: 100%;
        height: 100%;
        touch-action: none;
        user-select: none;
      }

      .basket {
        position: absolute;
        right: 18px;
        bottom: 18px;
        width: 160px;
        height: 120px;
        border-radius: 22px 22px 28px 28px;
        background: linear-gradient(180deg, #f4c992 0%, #d49a5f 70%, #b6783e 100%);
        border: 3px solid #8a5a36;
        box-shadow: 0 14px 24px rgba(0, 0, 0, 0.2);
        display: grid;
        place-items: center;
        color: #4a2c16;
        font-weight: 900;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        pointer-events: none;
        z-index: 1;
      }

      .basket::before {
        content: "";
        position: absolute;
        top: -12px;
        left: 8px;
        right: 8px;
        height: 22px;
        border-radius: 16px;
        background: linear-gradient(180deg, #f9ddb4 0%, #e2b57d 100%);
        border: 2px solid #8a5a36;
        box-shadow: inset 0 -2px 0 rgba(0, 0, 0, 0.12);
      }

      .basket::after {
        content: "";
        position: absolute;
        inset: 18px 10px 12px;
        border-radius: 12px 12px 18px 18px;
        background-image: linear-gradient(90deg, rgba(255, 255, 255, 0.22) 0 14px, transparent 14px 28px),
          linear-gradient(180deg, rgba(90, 50, 25, 0.2) 0 8px, transparent 8px 16px);
        background-size: 28px 100%, 100% 16px;
        opacity: 0.65;
        pointer-events: none;
      }

      .basket-active {
        box-shadow: 0 0 0 4px rgba(244, 162, 89, 0.6), 0 14px 24px rgba(0, 0, 0, 0.2);
        transform: translateY(-2px) scale(1.02);
      }

      .soil {
        position: absolute;
        width: var(--size);
        height: var(--size);
        border-radius: 6px;
        border: none;
        background-color: var(--soil-mid);
        background-image: repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.06) 0,
            rgba(255, 255, 255, 0.06) 6px,
            rgba(0, 0, 0, 0.08) 6px,
            rgba(0, 0, 0, 0.08) 12px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(255, 255, 255, 0.04) 0,
            rgba(255, 255, 255, 0.04) 6px,
            rgba(0, 0, 0, 0.1) 6px,
            rgba(0, 0, 0, 0.1) 12px
          ),
          linear-gradient(180deg, rgba(255, 255, 255, 0.15), transparent 40%),
          linear-gradient(180deg, rgba(0, 0, 0, 0.2), transparent 45%);
        box-shadow: 0 4px 0 #4f2a12, 0 10px 18px rgba(0, 0, 0, 0.28);
        display: grid;
        place-items: center;
        cursor: grab;
        animation: popIn 140ms ease-out;
        touch-action: none;
        user-select: none;
      }

      .soil:active {
        cursor: grabbing;
      }

      .soil-dragging {
        transform: scale(1.06);
        box-shadow: 0 10px 0 #5a341c, 0 20px 30px rgba(0, 0, 0, 0.3);
        z-index: 2;
      }

      .soil-picked {
        animation: popOut 200ms ease-in forwards;
      }

      .soil-missed {
        animation: sink 220ms ease-in forwards;
      }

      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(26, 18, 12, 0.55);
        display: grid;
        place-items: center;
        text-align: center;
        padding: 24px;
        z-index: 2;
      }

      .overlay[hidden] {
        display: none;
      }

      .result {
        background: #fff6ea;
        border-radius: 20px;
        padding: 20px 26px;
        max-width: 360px;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.25);
        display: grid;
        gap: 10px;
      }

      .result h2 {
        margin: 0 0 8px;
        font-size: 28px;
        min-height: 34px;
      }

      .result p {
        margin: 0;
        color: var(--ink-soft);
      }

      .hint {
        font-weight: 600;
      }

      .overlay-start {
        width: 100%;
      }

      @keyframes popIn {
        from {
          transform: scale(0.5);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes popOut {
        to {
          transform: scale(1.2);
          opacity: 0;
        }
      }

      @keyframes sink {
        to {
          transform: translateY(12px) scale(0.65);
          opacity: 0;
        }
      }

      @media (max-width: 720px) {
        body {
          padding: 16px;
        }

        .panel {
          padding: 16px;
        }

        button {
          width: 100%;
        }

        .basket {
          width: 130px;
          height: 100px;
          right: 12px;
          bottom: 12px;
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <header class="hero">
        <div>
          <h1>土ひろい10秒ゲーム</h1>
          <p>ランダムに出てくる土をドラッグしてカゴに入れよう。配点が高い土ほど早く消える！</p>
        </div>
        <div class="badge">10秒チャレンジ</div>
      </header>

      <section class="panel">
        <div class="stats">
          <div class="stat">
            残り時間
            <span id="time">01:00</span>
          </div>
          <div class="stat">
            スコア
            <span id="score">0</span>
          </div>
          <div class="stat">
            目標
            <span id="targetDisplay">--</span>
          </div>
        </div>

        <div class="controls">
          <div class="control-row">
            <label>
              制限時間（分）
              <input id="minutes" type="number" min="1" max="30" step="1" value="1" />
            </label>
            <label>
              目標スコア
              <input id="targetInput" type="number" min="1" max="999" step="1" value="18" />
            </label>
          </div>

          <fieldset>
            <legend>難易度</legend>
            <div class="difficulty">
              <label><input type="radio" name="difficulty" value="easy" /> かんたん</label>
              <label><input type="radio" name="difficulty" value="normal" checked /> ふつう</label>
              <label><input type="radio" name="difficulty" value="hard" /> むずい</label>
            </div>
          </fieldset>

          <div class="legend" aria-label="土の配点">
            <div class="legend-item"><span class="legend-dot" style="--legend-color: #c7a070"></span>1点</div>
            <div class="legend-item"><span class="legend-dot" style="--legend-color: #b37a4a"></span>2点</div>
            <div class="legend-item"><span class="legend-dot" style="--legend-color: #9a5c32"></span>3点</div>
            <div class="legend-item"><span class="legend-dot" style="--legend-color: #7f3f1f"></span>5点</div>
          </div>

          <p class="tuning" id="tuningInfo">出現間隔: -- / 基本生存時間: -- / 同時上限: --</p>

          <div class="buttons">
            <button class="btn-start" id="startBtn" type="button">Start</button>
            <button class="btn-reset" id="resetBtn" type="button">Reset</button>
          </div>
        </div>
      </section>

      <section class="field-wrap" aria-live="polite">
        <div id="field">
          <div class="basket" id="basket">BASKET</div>
        </div>
        <div class="overlay" id="overlay">
          <div class="result">
            <h2 id="resultTitle"></h2>
            <p id="resultDetail"></p>
            <p class="hint" id="hint">Startを押して開始</p>
            <button class="btn-start overlay-start" id="overlayStartBtn" type="button">Start</button>
          </div>
        </div>
      </section>
    </main>

    <script>
      const timeEl = document.getElementById("time");
      const scoreEl = document.getElementById("score");
      const targetDisplayEl = document.getElementById("targetDisplay");
      const minutesInput = document.getElementById("minutes");
      const targetInput = document.getElementById("targetInput");
      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const field = document.getElementById("field");
      const basket = document.getElementById("basket");
      const overlay = document.getElementById("overlay");
      const resultTitle = document.getElementById("resultTitle");
      const resultDetail = document.getElementById("resultDetail");
      const hintEl = document.getElementById("hint");
      const overlayStartBtn = document.getElementById("overlayStartBtn");
      const tuningInfo = document.getElementById("tuningInfo");
      const difficultyInputs = Array.from(document.querySelectorAll('input[name="difficulty"]'));

      const difficultyPresets = {
        easy: { spawnEveryMs: 950, ttlMs: 2400, target: 12 },
        normal: { spawnEveryMs: 700, ttlMs: 1600, target: 18 },
        hard: { spawnEveryMs: 520, ttlMs: 1200, target: 26 },
      };

      const soilTypes = [
        {
          id: "common",
          points: 1,
          ttlFactor: 1.4,
          weight: 45,
          colors: { light: "#d4ae7f", mid: "#b17b4d", dark: "#8b5a33" },
        },
        {
          id: "good",
          points: 2,
          ttlFactor: 1.1,
          weight: 30,
          colors: { light: "#c6935e", mid: "#a0663b", dark: "#7a4a28" },
        },
        {
          id: "rare",
          points: 3,
          ttlFactor: 0.85,
          weight: 18,
          colors: { light: "#b67b4c", mid: "#8f5431", dark: "#6b3a1f" },
        },
        {
          id: "legend",
          points: 5,
          ttlFactor: 0.65,
          weight: 7,
          colors: { light: "#a9663f", mid: "#7a3e20", dark: "#4e240f" },
        },
      ];

      const tuning = {
        maxOnScreen: 6,
      };

      const config = {
        spawnEveryMs: difficultyPresets.normal.spawnEveryMs,
        ttlMs: difficultyPresets.normal.ttlMs,
        maxOnScreen: tuning.maxOnScreen,
      };

      const bgmSequence = [
        { freq: 523.25, length: 0.16 },
        { freq: 659.25, length: 0.16 },
        { freq: 783.99, length: 0.16 },
        { freq: 659.25, length: 0.16 },
        { freq: 523.25, length: 0.16 },
        { freq: 587.33, length: 0.16 },
        { freq: 698.46, length: 0.16 },
        { freq: 587.33, length: 0.16 },
        { freq: 659.25, length: 0.16 },
        { freq: 783.99, length: 0.16 },
        { freq: 880.0, length: 0.16 },
        { freq: 783.99, length: 0.16 },
        { freq: 659.25, length: 0.16 },
        { freq: 698.46, length: 0.16 },
        { freq: 783.99, length: 0.16 },
        { freq: 698.46, length: 0.16 },
      ];
      const bgmLookaheadMs = 120;
      const bgmScheduleAheadTime = 0.6;
      const bgmState = {
        isPlaying: false,
        schedulerId: null,
        nextNoteTime: 0,
        stepIndex: 0,
      };
      let audioContext = null;
      let bgmMasterGain = null;

      let running = false;
      let score = 0;
      let targetScore = difficultyPresets.normal.target;
      let timeLimitMs = 1 * 60 * 1000;
      let endTime = 0;
      let spawnTimerId = null;
      let countdownTimerId = null;
      let soilCounter = 0;
      const soils = new Map();
      const dragState = {
        id: null,
        pointerId: null,
        offsetX: 0,
        offsetY: 0,
      };

      const clampNumber = (value, min, max) => Math.min(Math.max(value, min), max);

      const ensureAudioContext = () => {
        if (!audioContext) {
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          audioContext = new AudioContextClass();
          bgmMasterGain = audioContext.createGain();
          bgmMasterGain.gain.value = 0.16;
          bgmMasterGain.connect(audioContext.destination);
        }
        return audioContext;
      };

      const playBgmTone = (frequency, startTime, duration) => {
        if (!frequency || !audioContext || !bgmMasterGain) return;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(frequency, startTime);
        gain.gain.setValueAtTime(0.0001, startTime);
        gain.gain.linearRampToValueAtTime(0.12, startTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);
        osc.connect(gain);
        gain.connect(bgmMasterGain);
        osc.start(startTime);
        osc.stop(startTime + duration + 0.05);
      };

      const scheduleBgm = () => {
        if (!audioContext || !bgmState.isPlaying) return;
        const now = audioContext.currentTime;
        while (bgmState.nextNoteTime < now + bgmScheduleAheadTime) {
          const step = bgmSequence[bgmState.stepIndex];
          playBgmTone(step.freq, bgmState.nextNoteTime, step.length);
          bgmState.nextNoteTime += step.length;
          bgmState.stepIndex = (bgmState.stepIndex + 1) % bgmSequence.length;
        }
      };

      const startBgm = () => {
        const ctx = ensureAudioContext();
        if (ctx.state === "suspended") {
          ctx.resume();
        }
        if (bgmState.isPlaying) return;
        bgmState.isPlaying = true;
        bgmState.stepIndex = 0;
        bgmState.nextNoteTime = ctx.currentTime + 0.05;
        bgmState.schedulerId = setInterval(scheduleBgm, bgmLookaheadMs);
      };

      const stopBgm = () => {
        if (!bgmState.isPlaying) return;
        bgmState.isPlaying = false;
        clearInterval(bgmState.schedulerId);
        bgmState.schedulerId = null;
      };

      const formatTime = (ms) => {
        const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
        const seconds = String(totalSeconds % 60).padStart(2, "0");
        return `${minutes}:${seconds}`;
      };

      const updateTimeDisplay = (ms) => {
        timeEl.textContent = formatTime(ms);
      };

      const updateScoreDisplay = () => {
        scoreEl.textContent = score;
      };

      const updateTargetDisplay = () => {
        targetDisplayEl.textContent = targetScore;
      };

      const updateTuningInfo = () => {
        tuningInfo.textContent = `出現間隔: ${config.spawnEveryMs}ms / 基本生存時間: ${config.ttlMs}ms / 同時上限: ${config.maxOnScreen}`;
      };

      const setOverlayState = (state) => {
        if (state === "running") {
          overlay.hidden = true;
          return;
        }

        overlay.hidden = false;
        overlayStartBtn.hidden = false;
        overlayStartBtn.disabled = false;

        if (state === "idle") {
          resultTitle.textContent = "";
          resultDetail.textContent = "";
          hintEl.textContent = "Startを押して開始";
          hintEl.hidden = false;
          overlayStartBtn.textContent = "Start";
          return;
        }

        if (state === "result") {
          hintEl.hidden = true;
          overlayStartBtn.textContent = "もう一度Start";
        }
      };

      const setControlsEnabled = (enabled) => {
        minutesInput.disabled = !enabled;
        targetInput.disabled = !enabled;
        difficultyInputs.forEach((input) => {
          input.disabled = !enabled;
        });
        startBtn.disabled = !enabled;
      };

      const clearAllSoils = () => {
        soils.forEach((soil) => {
          clearTimeout(soil.timeoutId);
          soil.element.remove();
        });
        soils.clear();
        dragState.id = null;
        dragState.pointerId = null;
        basket.classList.remove("basket-active");
      };

      const readSettings = () => {
        const minutes = clampNumber(Number(minutesInput.value) || 1, 1, 30);
        timeLimitMs = minutes * 60 * 1000;
        const target = clampNumber(Number(targetInput.value) || 1, 1, 999);
        targetScore = target;
        updateTargetDisplay();
      };

      const applyDifficulty = (level, syncInput = true) => {
        const preset = difficultyPresets[level];
        if (!preset) return;
        config.spawnEveryMs = preset.spawnEveryMs;
        config.ttlMs = preset.ttlMs;
        if (syncInput) {
          targetInput.value = preset.target;
        }
        targetScore = Number(targetInput.value) || preset.target;
        updateTargetDisplay();
        updateTuningInfo();
      };

      const removeSoil = (id, reason) => {
        const entry = soils.get(id);
        if (!entry) return;
        clearTimeout(entry.timeoutId);
        soils.delete(id);
        const el = entry.element;
        el.disabled = true;
        el.style.pointerEvents = "none";
        if (dragState.id === id) {
          dragState.id = null;
          dragState.pointerId = null;
          basket.classList.remove("basket-active");
        }
        el.classList.add(reason === "picked" ? "soil-picked" : "soil-missed");
        const delay = reason === "picked" ? 180 : 220;
        setTimeout(() => el.remove(), delay);
      };

      const addScore = (points) => {
        score += points;
        updateScoreDisplay();
      };

      const getFieldBounds = () => {
        const rect = field.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) return rect;
        const parentRect = field.parentElement?.getBoundingClientRect();
        return parentRect ?? rect;
      };

      const pickWeighted = (items) => {
        const total = items.reduce((sum, item) => sum + item.weight, 0);
        let roll = Math.random() * total;
        for (const item of items) {
          roll -= item.weight;
          if (roll <= 0) return item;
        }
        return items[items.length - 1];
      };

      const isInBasket = (soilRect, basketRect) => {
        const centerX = soilRect.left + soilRect.width / 2;
        const centerY = soilRect.top + soilRect.height / 2;
        return (
          centerX >= basketRect.left &&
          centerX <= basketRect.right &&
          centerY >= basketRect.top &&
          centerY <= basketRect.bottom
        );
      };

      const updateBasketHighlight = (pointerX, pointerY) => {
        const rect = basket.getBoundingClientRect();
        if (pointerX >= rect.left && pointerX <= rect.right && pointerY >= rect.top && pointerY <= rect.bottom) {
          basket.classList.add("basket-active");
        } else {
          basket.classList.remove("basket-active");
        }
      };

      const spawnSoil = () => {
        if (!running) return;
        if (soils.size >= config.maxOnScreen) return;
        const rect = getFieldBounds();
        const size = clampNumber(Math.round(46 + Math.random() * 34), 46, 80);
        if (rect.width < size || rect.height < size) return;
        const maxX = Math.max(0, rect.width - size);
        const maxY = Math.max(0, rect.height - size);
        const x = Math.random() * maxX;
        const y = Math.random() * maxY;
        const soilType = pickWeighted(soilTypes);
        const ttlMs = Math.round(config.ttlMs * soilType.ttlFactor);

        const soil = document.createElement("button");
        soil.type = "button";
        soil.className = "soil";
        soil.style.setProperty("--size", `${size}px`);
        soil.style.setProperty("--soil-light", soilType.colors.light);
        soil.style.setProperty("--soil-mid", soilType.colors.mid);
        soil.style.setProperty("--soil-dark", soilType.colors.dark);
        soil.style.left = `${x}px`;
        soil.style.top = `${y}px`;
        soil.textContent = "";
        soil.setAttribute("aria-label", "土をドラッグ");

        const id = ++soilCounter;
        const timeoutId = setTimeout(() => removeSoil(id, "missed"), ttlMs);
        soils.set(id, { element: soil, timeoutId, points: soilType.points, size });

        soil.addEventListener(
          "pointerdown",
          (event) => {
            if (!running) return;
            event.preventDefault();
            const entry = soils.get(id);
            if (entry) {
              clearTimeout(entry.timeoutId);
              entry.timeoutId = null;
            }
            soil.setPointerCapture(event.pointerId);
            dragState.id = id;
            dragState.pointerId = event.pointerId;
            const rect = soil.getBoundingClientRect();
            dragState.offsetX = event.clientX - rect.left;
            dragState.offsetY = event.clientY - rect.top;
            soil.classList.add("soil-dragging");
            updateBasketHighlight(event.clientX, event.clientY);
          },
          { passive: false }
        );

        soil.addEventListener(
          "pointermove",
          (event) => {
            if (dragState.id !== id || dragState.pointerId !== event.pointerId) return;
            const fieldRect = getFieldBounds();
            const nextX = clampNumber(event.clientX - fieldRect.left - dragState.offsetX, 0, fieldRect.width - size);
            const nextY = clampNumber(event.clientY - fieldRect.top - dragState.offsetY, 0, fieldRect.height - size);
            soil.style.left = `${nextX}px`;
            soil.style.top = `${nextY}px`;
            updateBasketHighlight(event.clientX, event.clientY);
          },
          { passive: false }
        );

        const finishDrag = (event) => {
          if (dragState.id !== id || dragState.pointerId !== event.pointerId) return;
          soil.releasePointerCapture(event.pointerId);
          soil.classList.remove("soil-dragging");
          const basketRect = basket.getBoundingClientRect();
          const soilRect = soil.getBoundingClientRect();
          if (isInBasket(soilRect, basketRect)) {
            addScore(soilType.points);
            removeSoil(id, "picked");
          } else {
            basket.classList.remove("basket-active");
          }
          dragState.id = null;
          dragState.pointerId = null;
        };

        soil.addEventListener("pointerup", finishDrag);
        soil.addEventListener("pointercancel", finishDrag);

        field.appendChild(soil);
      };

      const showResult = () => {
        const win = score >= targetScore;
        resultTitle.textContent = win ? "勝ち！" : "負け…";
        resultDetail.textContent = `スコア ${score} / 目標 ${targetScore}`;
        setOverlayState("result");
      };

      const startGame = () => {
        if (running) return;
        running = true;
        score = 0;
        soilCounter = 0;
        clearAllSoils();
        readSettings();
        updateScoreDisplay();
        updateTimeDisplay(timeLimitMs);
        setOverlayState("running");
        setControlsEnabled(false);
        startBgm();
        endTime = performance.now() + timeLimitMs;

        countdownTimerId = setInterval(() => {
          const remaining = endTime - performance.now();
          if (remaining <= 0) {
            updateTimeDisplay(0);
            endGame();
            return;
          }
          updateTimeDisplay(remaining);
        }, 200);

        spawnSoil();
        spawnTimerId = setInterval(spawnSoil, config.spawnEveryMs);
      };

      const endGame = () => {
        if (!running) return;
        running = false;
        clearInterval(spawnTimerId);
        clearInterval(countdownTimerId);
        spawnTimerId = null;
        countdownTimerId = null;
        clearAllSoils();
        stopBgm();
        setControlsEnabled(true);
        showResult();
      };

      const resetGame = () => {
        running = false;
        clearInterval(spawnTimerId);
        clearInterval(countdownTimerId);
        spawnTimerId = null;
        countdownTimerId = null;
        clearAllSoils();
        stopBgm();
        score = 0;
        readSettings();
        updateScoreDisplay();
        updateTimeDisplay(timeLimitMs);
        setOverlayState("idle");
        setControlsEnabled(true);
      };

      minutesInput.addEventListener("input", () => {
        if (running) return;
        readSettings();
        updateTimeDisplay(timeLimitMs);
      });

      targetInput.addEventListener("input", () => {
        if (running) return;
        readSettings();
        updateTargetDisplay();
      });

      difficultyInputs.forEach((input) => {
        input.addEventListener("change", () => {
          if (input.checked) {
            applyDifficulty(input.value);
            if (!running) {
              readSettings();
              updateTargetDisplay();
            }
          }
        });
      });

      startBtn.addEventListener("click", startGame);
      resetBtn.addEventListener("click", resetGame);
      overlayStartBtn.addEventListener("click", startGame);

      applyDifficulty("normal", false);
      updateScoreDisplay();
      readSettings();
      updateTimeDisplay(timeLimitMs);
      updateTuningInfo();
      setOverlayState("idle");
    </script>
  </body>
</html>
